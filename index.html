<html>
<head>
<title>ogl26sn</title>
<meta name="description" content="Hier bist du richtig, Nicky" />
<meta name="google-site-verification" content="D_CZHuofMbGyubazdnw2MyEuwYo67--haSx0Uqlj8js" />
<style>
body {
    display: block;
    margin: 0px;
}

</style>
</head>
<body>
</body>
<script src="https://threejs.org/build/three.min.js"></script>
<script type="text/javascript">
var scene = new THREE.Scene();
var width = window.innerWidth;
var height = window.innerHeight;
var divHeight = 5;
var divWidth = 11;
var cubeWidth = width / divWidth;
var cubeHeight = height / divHeight;
var solutionCubes = [];
var blackList = [];
var toRotate = [];
document.addEventListener( 'mousedown', onDocumentMouseDown, false );
var str = 'RtxORlVORFZJRVJaSUdUQVVTRU5EWldFSUhVTkRFUlREUkVJWkVITg==';
var progress = 0;

function addLetter(string,textsize,maxwidth){
	// create a canvas element
	var canvas1 = document.createElement('canvas');
	canvas1.width = 256;
	canvas1.height = 256;
	var context1 = canvas1.getContext('2d');
	context1.font = "Bold "+Math.floor(textsize*0.7)+"px Arial";
	context1.fillStyle = "rgba(0,0,0,0.95)";
    context1.fillText(string, 66, 186, maxwidth);
    
	// canvas contents will be used for a texture
	var texture1 = new THREE.Texture(canvas1) 
	texture1.needsUpdate = true;
	
      
    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
    material1.transparent = true;

    var mesh1 = new THREE.Mesh(
        new THREE.PlaneGeometry(canvas1.width, canvas1.height),
        material1
      );
	  console.log(canvas1.width);
	mesh1.position.set(0,0,-2);
	mesh1.rotation.x = Math.PI;
	return mesh1;
}

function onDocumentMouseDown( e ) {
  e.preventDefault();
  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();
  
  	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		raycaster.setFromCamera( mouse, camera , 250, 500);

	// calculate objects intersecting the picking ray
	var intersects = raycaster.intersectObjects( scene.children );
	//intersects[ 0 ].object.material = new THREE.MeshLambertMaterial( { color: 0xff0000} );
  toRotate.push(intersects[ 0 ].object);
}


var camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );
//var camera = new THREE.PerspectiveCamera( 80, width / height, 1, 10000 );
scene.add( camera );

var renderer = new THREE.WebGLRenderer();
renderer.setSize( window.innerWidth, window.innerHeight );
renderer.shadowMap.enabled = true;
renderer.shadowMapSoft = true;
renderer.shadowMap.type = THREE.PCFShadowMap;


document.body.appendChild( renderer.domElement );

//container.appendChild(webglRenderer.domElement);

var geometry = new THREE.BoxBufferGeometry( cubeWidth, cubeHeight, 1 );
var material = new THREE.MeshLambertMaterial ( { color: 0x00ff00 } );
var cube = new THREE.Mesh( geometry, material );
cube.castShadow = true;
cube.receiveShadow = true;
var colors = [0x666699,0x336699,0xccccff,0x3399cc,0xff9966,0x996633,0xffcccc,0xcc6633,0xccff66,0x669933,0xccffcc,0xcccc33,0x663399,0x663399,0xccccff,0x9933cc];
var materials = [];
for (var i = 0; i < colors.length; i++){
	materials.push(new THREE.MeshLambertMaterial( { color: colors[i] } ));
}
var cubes = [];

str = atob(str);
for (var x = 0; x < divWidth; x++){
	for (var y = 0; y < divHeight; y++){
  	var newCube = cube.clone();
    newCube.position.x = - width / 2 + cubeWidth*x+cubeWidth/2;
	newCube.position.y= -height / 2 + cubeHeight*y+cubeHeight/2;
    newCube.scale.z = (Math.random()*24);
    newCube.material = materials[Math.floor(Math.random()*materials.length)];
	cubes.push(newCube);
    scene.add(newCube);
	
	
  }
}
var usedIndices = [];
for (var i = 0; i < str.length; i++){
	var index = Math.floor(Math.random()*cubes.length);
	while (usedIndices.includes(index)){
		index = Math.floor(Math.random()*cubes.length);
	}
	var cube = cubes[index];
	usedIndices.push(index);
	cube.add(addLetter(str[i],cubeHeight, cubeWidth));
	solutionCubes.push(cube);
}


camera.position.z = 251;

//camera.position.y = -451;
//camera.rotation.x = 20;
//camera.lookAt({x:0,y:0,z:0});

scene.add( new THREE.AmbientLight( 0xaaaaaa) );
var light = new THREE.DirectionalLight(0xffffff, 1);
light.castShadow = true;
light.position.y = 1000;
light.position.x = 800;
light.position.z = 450;
light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 70, 1, 550, 2300 ) );

light.shadow.bias = -0.0003;
light.shadow.mapSize.width = 2048;
light.shadow.mapSize.height = 2048;
scene.add(light);
//var helper = new THREE.CameraHelper( light.shadow.camera );
//scene.add( helper );

//Add secret text


function render() {
  //cube.rotation.x += 0.1;

   //camera.position.z = Math.cos(timer) * 1000;
   //camera.position.y = Math.sin(timer) * 1000;
   for (var i = 0; i < toRotate.length; i++){
    if ( blackList.includes(toRotate[i])){
		toRotate.splice(i, 1);
		continue;
	}
   toRotate[i].rotation.x += 0.05;
    if (toRotate[i].rotation.x > Math.PI && solutionCubes[progress] === toRotate[i]){
	 blackList.push(toRotate[i]);
	 toRotate[i].rotation.x = Math.PI;
	 toRotate.splice(i, 1);
	 progress++;
	}
   else if (toRotate[i].rotation.x > Math.PI*2){
	toRotate[i].rotation.x = 0;
   	 toRotate.splice(i, 1);
   }
   }
  camera.lookAt(scene.position);
	requestAnimationFrame( render );
	renderer.render( scene, camera );
}
render();
</script>
</html>